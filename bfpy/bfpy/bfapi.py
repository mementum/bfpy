#!/usr/bin/env python
# -*- coding: latin-1; py-indent-offset:4 -*-
################################################################################
# 
# This file is part of BfPy
#
# BfPy is a Python library to communicate with the Betfair Betting Exchange
# Copyright (C) 2010  Daniel Rodriguez (aka Daniel Rodriksson)
#
# You can learn more and contact the author at:
#
#    http://code.google.com/p/bfpy/
#
# BfPy is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# BfPy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with BfPy. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
'''
BfApi object implemenation.

It does initialize suds logging to a L{NullHandler} to avoid any logging output
'''

from copy import copy
from collections import namedtuple
from datetime import datetime
from socket import error as SocketError

import suds.client

import bferror
from bfservice import BfService, GlobalServiceDef, ExchangeServiceDef, GlobalObject, ExchangeObject
from bfprocessors import *
import bftransport
import bfwsdl

preProcess = True
postProcess = True
eventRootId = -1

Global = 0
ExchangeUK = 1
ExchangeAus = 2


class BfApi(object):
    '''
    The class implements a unified communication interface with the Betfair API Services
    EndPoints (Global, ExchangeUK, ExchangeAus)

    This is done by defining the the services and object retrieval methods by means of
    non-data descriptors. The descriptors are added to the class by the metaclass {BfService}

    The class can be configured to avoid any pre/post-processing of the requests and answers
    by changing the module L{preProcess} and L{postProcess} variables or passing them as
    named arguments to the constructor

    @ivar preProcess: whether service requests will undergo pre-processing
    @type preProcess: bool
    @ivar postProcess: whether service requests will undergo post-processing
    @type postProcess: bool
    @ivar transport: a reference to the L{BfTransport} used to communicate (HTTP)
                     with the Betfair servers
    @type transport: L{BfTransport}
    @ivar clients: the actual suds clients to generate, transport and proccess
                   the service communication
    @type clients: dict

    @ivar serviceDefs: service definitions with non-data descriptors
    @type clients: list
    '''

    __metaclass__ = BfService

    wsdlDefs = {
        Global: bfwsdl.BFGlobalService,
        ExchangeUK: bfwsdl.BFExchangeService,
        ExchangeAus: bfwsdl.BFExchangeServiceAus
        }


    def __init__(self, preProcess=preProcess, postProcess=postProcess):
        '''
        Initializes the processing options, transport and service clients

        @param preProcess: whether service requests will undergo pre-processing
        @type preProcess: bool
        @param postProcess: whether service requests will undergo post-processing
        @type postProcess: bool
        '''
        self.preProcess = preProcess
        self.postProcess = postProcess

        self.transport = bftransport.BfTransport()
        self.clients = dict()
        for endPoint, wsdlDef in self.wsdlDefs.iteritems():
            self.clients[endPoint] = suds.client.Client(wsdlDef, transport=self.transport.clone())


    def clone(self):
        '''
        Returns an intelligent cloned object.

        All objects are copied, then clients are also "cloned" themselves and
        the sessionToken is ended

        @return: a clone of itself
        @rtype: L{BfApi}
        '''
        obj = copy.copy(self)

        for endPoint, client in self.clients.iteritems():
            obj.clients[endPoint] = client.clone()

        self.sessionToken = ''

        return obj


    def getService(self, endPoint, serviceName):
        '''
        Returns a service from an endPoint

        @param endPoint: suds client to retrieve the service from
        @type endPoint: int
        @param serviceName: name of the service to be retrieved
        @type serviceName: str

        @return: a service to be invoked
        @rtype: method generated by suds from the WSDL definition
        '''
        return getattr(self.clients[endPoint].service, serviceName)


    def getObject(self, endPoint, objectName):
        '''
        Returns an object from an endPoint

        @param endPoint: suds client to retrieve the service from
        @type endPoint: int
        @param objectName: name of the object to be retrieved
        @type objectName: str

        @return: the requested object
        @rtype: object generated by suds from the WSDL definitions
        '''
        return self.clients[endPoint].factory.create('ns1:%s' % objectName)


    def getHeader(self, endPoint):
        '''
        All methods (but login) add a header to the request. This method
        retrieves the header object

        @param endPoint: suds client to retrieve the service from
        @type endPoint: int

        @return: the API header
        @rtype: object generated by suds from the WSDL definitions
        '''
        header = self.getObject(endPoint, 'APIRequestHeader')

	header.clientStamp = 0
	header.sessionToken = self.sessionToken

        return header


    def getRequest(self, endPoint, requestName, apiHeader=True): 
        '''
        All methods pass a request object to services. Because login does
        not carry a header, we need to know if the header has to be added
        retrieves the header object

        @param endPoint: suds client to retrieve the service from
        @type endPoint: int
        @param requestName: name of the object to be retrieved
        @type requestName: str

        @return: the request object
        @rtype: object generated by suds from the WSDL definitions
        '''
        request = self.getObject(endPoint, requestName)

        if apiHeader:
            request.header = self.getHeader(endPoint)

        return request


    def invoke(self, methodName, service, request, skipErrorCodes):
        '''
        Invokes a service with a given request and with a list of errors
        that do not generate exceptions if returned

        @param methodName: method name that has been used to invoke
        @type methodName: str
        @param service: name of the object to be retrieved
        @type service: method generated by suds from the WSDL definition
        @param skipErrorCodes: error codes that will not generate exceptions
        @type skipErrorCodes: list

        @return: the response object processed by suds
        @rtype: object generated by suds from the WSDL definitions

        @raise BfHttpError: if the server does not answer with 200 OK
        @raise BfNetworkError: on (potential) network errors
        @raise Exception: on other errors, due to the fact that suds does not
                          generate all exceptions from a common base
        @raise BfApiError: on specific API errors
        @raise BfServiceError: on service errors (unless specified in skipErrorCodes)
        '''
        try:
            response = service(request)
        except suds.WebFault, e:
            raise bferror.BfHttpError(methodName, e, str(e), e.fault, e.document)
        except (SocketError, bftransport.TransportException), e:
            # Summarise (all potential) network errors into a generic notification
            raise bferror.BfNetworkError(methodName, e, str(e), e.args)
        except Exception, e:
            # Catch all - needed because suds doesn't have a root class Exception
            # and also produces some standard exceptions
            raise bferror.BfError(methodName, e, str(e), e.args)

        # Analyze API errorCodes
        if response.header.errorCode != 'OK':
            raise bferror.BfApiError(methodName, response, str(response), response.header.errorCode)

        # Analyze Service errorCodes - keepAlive (at least) has no "errorCode" field
        if hasattr(response, 'errorCode'):
            if response.errorCode != 'OK' and response.errorCode not in skipErrorCodes:
                raise bferror.BfServiceError(methodName, response, str(response), response.errorCode)

        # Save the latest session token
        self.sessionToken = response.header.sessionToken
        
        return response


    MinStakes = namedtuple('CurrencyMinStakes', ('minimumStake', 'minimumRangeStake', 'minimumBSPLayLiability'))
    # minimumStake, minimumRangeStake, minimumBSPLayLiability
    MinBets = {
        'AUD': MinStakes(5.0, 3.0, 30.0),
        'CAD': MinStakes(6.0, 3.0, 30.0),
        'DKK': MinStakes(30.0, 15.0, 150.0),
        'EUR': MinStakes(2.0, 2.0, 20.0),
        'HKD': MinStakes(25.0, 15.0, 125.0),
        'NOK': MinStakes(30.0, 15.0, 150.0),
        'SGD': MinStakes(6.0, 1.0, 30.0),
        'SEK': MinStakes(30.0, 15.0, 150.0),
        'GBP': MinStakes(2.0, 1.0, 10.0),
        'USD': MinStakes(4.0, 2.0, 20.0),
        }

    @staticmethod
    def getMinStakes(currency):
        '''
        Returns the minimum stakes for standard bets, range and BSP liability

        Useful for Free API applications that cannot call getAllCurrencies(V2)

        @param currency: the currency for which the minimum stakes are sought
        @type currency: str (3 letter code)

        @returns: the minimum stakes (minimumStake, minimumRangeStake, minimumBSPLayLiability
        @rtype: namedtuple
        '''
        return self.MinBets[currency]

    serviceDefs = [
        # ######################
        # API Object Retrieval
        # ######################
        GlobalObject('Event', eventId=-1, eventName=''),
        ExchangeObject('Market'),
        ExchangeObject('Runner'),
        ExchangeObject('MarketPrices'),
        ExchangeObject('RunnerPrices'),
        ExchangeObject('Price'),
        ExchangeObject('PlaceBets', betCategoryType='E', bspLiability=0.0),
        ExchangeObject('CancelBets'),
        ExchangeObject('UpdateBets'),
        
        # ######################
        # General API Services
        # ######################
        GlobalServiceDef('login', apiHeader=False,
                         preProc=[PreProcLogin()], postProc=[ProcLogin()],
                         productId=82, vendorSoftwareId=0, ipAddress='0', locationId=0),
        GlobalServiceDef('logout'),
        GlobalServiceDef('keepAlive'),

        # ######################
        # Read-Only API Services
        # ######################
        GlobalServiceDef('convertCurrency'),
        GlobalServiceDef('getActiveEventTypes', requestName='GetEventTypesReq', skipErrorCodes=['NO_RESULTS'],
                         postProc=[ArrayFix('eventTypeItems', 'EventType')]),
        GlobalServiceDef('getAllCurrencies', requestName='GetCurrenciesReq', postProc=[ArrayFix('currencyItems', 'Currency')]),
        GlobalServiceDef('getAllCurrenciesV2', requestName='GetCurrenciesV2Req', postProc=[ArrayFix('currencyItems', 'CurrencyV2')]),
        GlobalServiceDef('getAllEventTypes', requestName='GetEventTypesReq', skipErrorCodes=['NO_RESULTS'],
                         postProc=[ArrayFix('eventTypeItems', 'EventType')]),
        ExchangeServiceDef('getAllMarkets', postProc=[ProcAllMarkets()]),
        # MISSING GetBet
        # MISSING GetBetHistory
        # MISSING GetBetLite
        # MISSING GetBetMatchesLite
        # ExchangeServiceDef('getCompleteMarketPricesCompressed', postProc=[ProcMarketPricesCompressed(True)]),
        ExchangeServiceDef('getCurrentBets', skipErrorCodes=['NO_RESULTS'], postProc=[ArrayFix('bets', 'Bet'), ProcCurrentBets()],
                           detailed=False, orderBy='NONE', marketId=0, recordCount=0, startRecord=0, noTotalRecordCount=True),
        # MISSING GetCurrentBetsLite
        # MISSING GetDetailAvailableMarketDepth
        GlobalServiceDef('getEvents', skipErrorCodes=['NO_RESULTS'],
                         postProc=[ArrayFix('eventItems', 'BFEvent'), ArrayFix('marketItems', 'MarketSummary')]),
        # ExchangeServiceDef('getInPlayMarkets', postProc=[ProcAllMarkets()]),
        # Documentation incorrectly states that includeCouponLinks is optional
        ExchangeServiceDef('getMarket', postProc=[ProcMarket()], includeCouponLinks=False),
        ExchangeServiceDef('getMarketInfo'),
        # MISSING GetMarketPrices
        ExchangeServiceDef('getMarketPricesCompressed', postProc=[ProcMarketPricesCompressed()]),
        ExchangeServiceDef('getMUBets', postProc=[ArrayFix('bets', 'MUBet')],
                           betStatus='MU', excludeLastSecond=False,
                           matchedSince=datetime(2000, 01, 01, 00, 00, 00),
                           orderBy='BET_ID', recordCount=200, sortOrder='ASC', startRecord=0),
        # MISSING GetMUBetsLite
        ExchangeServiceDef('getMarketProfitAndLoss',
                           skipErrorCodes=['MARKET_CLOSED', 'INVALID_MARKET'],
                           preProc=[PreProcMarketProfitAndLoss()],
                           postProc=[ArrayFix('annotations', 'ProfitAndLoss'), ProcMarketProfitAndLoss()],
                           includeBspBets=False, includeSettledBets=False, netOfCommission=False),
        # MISSING GetMarketTradedVolume
        # MISSING GetMarketTradedVolumeCompressed
        # MISSING GetPrivateMarkets
        # MISSING GetSilks
        # MISSING GetSilkV2

        # ######################,
        # Bet Placement API Services
        # ######################
        ExchangeServiceDef('cancelBets', preProc=[ArrayUnfix('bets', 'CancelBets')],
                           postProc=[ArrayFix('betResults', 'CancelBetsResult')]),
        ExchangeServiceDef('cancelBetsByMarket', postProc=[ArrayFix('results', 'CancelBetsByMarketResults')]),
        ExchangeServiceDef('placeBets', preProc=[ArrayUnfix('bets', 'PlaceBets')],
                           postProc=[ArrayFix('betResults', 'PlaceBetsResult')]),
        ExchangeServiceDef('updateBets', preProc=[ArrayUnfix('bets', 'UpdateBets')],
                           postProc=[ArrayFix('betResults', 'UpdateBetsResult')]),

        # ######################
        # Acount Management API Services
        # ######################
        ExchangeServiceDef('getAccountFunds'),
        GlobalServiceDef('transferFunds'),

        # MISSING addPaymentCard
        # MISSING deletePaymentCard
        # MISSING depositFromPaymentCard
        # MISSING forgotPassword
        # MISSING getAccountStatement
        # MISSING getPaymentCard
        # MISSING getSubscriptionInfo
        # MISSING modifyPassword
        # MISSING modifyProfile
        # MISSING retrieveLIMBMessage
        # MISSING selfExclude
        # MISSING setChatName
        # MISSING submitLIMBMessage
        # MISSING updatePaymentCard
        # MISSING viewProfile
        # MISSING viewProfileV2 ???
        # MISSING viewReferAndEarn
        # MISSING withdrawToPaymentCard
        ]
